import funkin.modding.module.Module;
import funkin.play.PlayState;
import flixel.FlxG;
import funkin.util.Constants;
import funkin.Preferences;
import funkin.Conductor;
import funkin.play.notes.Strumline;
import flixel.math.FlxMath;
import flixel.util.FlxStringUtil;
import flixel.text.FlxText;
import flixel.text.FlxTextBorderStyle;
import funkin.Paths;
import funkin.audio.FunkinSound;
import funkin.ui.debug.charting.ChartEditorState;


//A script which colours the notes based on their quants (like NotITG)

class QuantSkinModule extends Module
{
	public var deSaturatedHolds:Bool = false;

	//IF YOU WANT YOUR SKIN TO USE QUANT LOGIC, ADD IT TO THIS ARRAY HERE!!!!
	public var quantSkinNames:Array<String> = [
		"simple", "simple_holdcovers", "groovin", "halvedhalvedhalved", "simple_simple", "memory", "doodle", "triangulate"
	];
	  
	  
	public function new() {
        super("QuantSkinModule");	
    }

	function onNoteIncoming(callback)
	{

		var isQuantSkin:Bool = false;
		
		var daNote = callback.note;		
		
		var noteStyleName:String = daNote.noteStyleName;
		
		if(noteStyleName == null){ //for base game support / failsafe
			noteStyleName = "funkin";
			switch (daNote.noteData.getStrumlineIndex())
			{
				case 0:
					noteStyleName = PlayState.instance.playerStrumline.noteStyle.id;
				case 1:
					noteStyleName = PlayState.instance.opponentStrumline.noteStyle.id;
			}
			
		}
		
		if(quantSkinNames.contains(noteStyleName.toLowerCase())){
			isQuantSkin = true;
		}
	//	PlayState.instance.debugNotification("hi: " + noteStyleName, 0xFF4949FF); 
		
		
		if(!isQuantSkin) return;
		
		
	
		daNote.hsvShader.value2 = 1;
		daNote.hsvShader.saturation2 = 1;
		if (daNote.holdNoteSprite != null) {
			daNote.holdNoteSprite.hsvShader.saturation = deSaturatedHolds ? 0 : 1; //reset saturation cuz of recycling
			daNote.holdNoteSprite.hsvShader.saturation2 = 1;
			daNote.holdNoteSprite.hsvShader.value2 = 1;
		}
		
		var hueResult:Float = setNoteHue(daNote);
		daNote.setHue(hueResult);
	
		//handle hold note
		if (daNote.holdNoteSprite != null) {
			daNote.holdNoteSprite.setHue(hueResult);
		}
	}
	
	//From Inhuman
	var arrowHSV_quant:Array<Array<Int>> = [
	[0, -10, 0,100],  	// 4
	[-145, -5, 5,100], 	// 8
	[-75, 7, -12,100], 	// 12
	[68, 0, 0,100], 	// 16
	[-25, -27, 0,100], 	// 24
	[32, 0, 0,100], 	// 32
	[175, -30, 20,100], // 48
	[140, -5, 0,100], 	// 64
	[0, -100, -35,100]	// unknown
	];
	

	public var hueQuantMap:Map<Int, Float> = [
	4 => 0,
	8 => -145,
	12 => -72,
	16 => 68,
	20 => -54,
	24 => -25,
	32 => 32,
	48 => 178,
	64 => 140
	];
	
	var hueQuantMap_sortedArray:Array<Int> = [];
	
	//All possible FNF timings: 4, 8, 12, 16, 20, 24, 32, 48, 64, 96, 192
	
	
	//Set to the column to print the notes for. -1 is disabled, 5 is all
	var debugPrint:Int = -1;
	
	public function setNoteHue(note):Float{
		var noteTime:Float = note.strumTime;		
		
		var beat:Float = Conductor.instance.getTimeInSteps(noteTime) / Constants.STEPS_PER_BEAT;

		//WITF Variables
		if (PlayState.instance.variables.exists("quantSkinBeatMult")) beat *= PlayState.instance.variables.get("quantSkinBeatMult");
		if (PlayState.instance.variables.exists("quantSkinBeatOffset")) beat += PlayState.instance.variables.get("quantSkinBeatOffset");

		//beat needs to be 0 for on beat, 0.5 for off beat, 0.25 for quartar beat, so on.		
		var beatRow = Math.round(beat * 48);
		
		

		if(debugPrint != -1){
			if(debugPrint > 4 || (note.direction == debugPrint && debugPrint != 5)){
				PlayState.instance.debugNotification("NoteBeat: " + beat, 0xFF4949FF); 
				PlayState.instance.debugNotification("NoteBeatRow: " + beatRow, 0xFF9945FF); 
			}
		}

		//Using an array so we can have the keys sorted to save on performance (so most common quants are checked first)
		if(hueQuantMap_sortedArray.length == 0){
			for (quant in hueQuantMap.keys()){
				hueQuantMap_sortedArray.push(quant);
			}
			hueQuantMap_sortedArray.sort(function(a, b) {
			  if (a < b) return -1;
			  else if (a  > b ) return 1;
			  else
				return 0;
			});
			//PlayState.instance.debugNotification("arr: " + hueQuantMap_sortedArray, 0xFFFFFF00); 
		}
		
		for (quant in hueQuantMap_sortedArray){
			//PlayState.instance.debugNotification("Checking: " + quant, 0xFF00FA12); 
			if (beatRow % (192 / quant) == 0){
				var h:Float = hueQuantMap.get(quant) / 360;
				//PlayState.instance.debugNotification("Found!: " + h, 0xFF24FF12); 
				return h;
			}
		}
		
		//PlayState.instance.debugNotification("Unknown! : " + beat + " - " + beatRow, 0xFFFF0000); 

		//note.hsvShader.saturation = 0;
		note.hsvShader.saturation2 = 0;
		note.hsvShader.value2 = 0.88;
		if (note.holdNoteSprite != null) {
			//note.holdNoteSprite.hsvShader.saturation = 0;
			note.holdNoteSprite.hsvShader.saturation2 = 0;
			note.holdNoteSprite.hsvShader.value2 = 0.88;
		}
		return -139;		
	}
	

	

}