#pragma header

//edited to work like Psych HSV. (For easier hue shifting)
//V0.7a - Now has stealth glow!
//V0.7.6a - Now has sudden and hidden stealth support for holds!
//V1.0.2 Experimental - Rewritten to support the new sustain code.


uniform float _hue;
uniform float _sat;
uniform float _val;

uniform float _hue2;
uniform float _sat2;
uniform float _val2;

uniform float _stealthGlow;
uniform float _stealthR;
uniform float _stealthG;
uniform float _stealthB;


uniform bool _isHold;

uniform float _bottomStealth;
uniform float _bottomAlpha;
uniform float _bottomRed;
uniform float _bottomGreen;
uniform float _bottomBlue;
uniform float _bottomStealthRed;
uniform float _bottomStealthGreen;
uniform float _bottomStealthBlue;

uniform float _topStealth;
uniform float _topAlpha;
uniform float _topRed;
uniform float _topGreen;
uniform float _topBlue;
uniform float _topStealthRed;
uniform float _topStealthGreen;
uniform float _topStealthBlue;

// HSV stuff
vec3 normalizeColor(vec3 color)
{
    return vec3(
        color[0] / 255.0,
        color[1] / 255.0,
        color[2] / 255.0
    );
}

vec3 rgb2hsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec4 applyStealth(vec4 curCol, float stealth, float stealthR, float stealthG, float stealthB)
{
    vec4 glow = vec4(stealthR,stealthG,stealthB, 1.0);	
	float _stealthGlow_clamped = clamp(stealth, 0.0, 1.0);
	glow *=  curCol[3]; //Apply Alpha from texture
	glow = clamp(glow, 0.0, 1.0);
    curCol = mix(curCol, glow, _stealthGlow_clamped);
    return curCol;
}

vec4 applyAlpha(vec4 curCol, float alpha)
{
	curCol *=  alpha;
    return curCol;
}


vec4 applyCol(vec4 curCol, float r, float g, float b)
{
    curCol.rgb *= vec3(r,g,b);
    return curCol;
}

vec4 applyHueShift(vec4 color)
{
	//Hue Sat Val
	vec4 swagColor = vec4(rgb2hsv(vec3(color[0], color[1], color[2])), color[3]);
	swagColor.x += _hue + _hue2;
	swagColor.y *= _sat * _sat2;
	swagColor.z *= _val * _val2;
	color = vec4(hsv2rgb(vec3(swagColor[0], swagColor[1], swagColor[2])), swagColor[3]);
    return color;
}

void main() {
	vec4 color = flixel_texture2D(bitmap, openfl_TextureCoordv);
	
	if(_isHold){
		vec4 colorTop = color;
		vec4 colorBottom = color;
		
		
		colorTop = applyCol(colorTop, _topRed,_topGreen, _topBlue );
		colorBottom = applyCol(colorBottom, _bottomRed, _bottomGreen,_bottomBlue );
		
		colorTop = applyAlpha(colorTop, _topAlpha);
		colorBottom = applyAlpha(colorBottom, _bottomAlpha);
	   
	   
		colorTop = applyHueShift(colorTop);
		colorBottom = applyHueShift(colorBottom);
		
	   
		colorTop = applyStealth(colorTop, _topStealth, _topStealthRed,_topStealthGreen, _topStealthBlue );
		colorBottom = applyStealth(colorBottom, _bottomStealth, _bottomStealthRed,_bottomStealthGreen, _bottomStealthBlue );
		
		
		colorTop = clamp(colorTop, 0.0, 1.0);
		colorBottom = clamp(colorBottom, 0.0, 1.0);
		
		color = mix(colorBottom, colorTop, openfl_TextureCoordv.y);
		
		
	}else{
		color = applyHueShift(color);
		color = applyStealth(color, _stealthGlow, _stealthR, _stealthG, _stealthB);
	}
	
	
	gl_FragColor = color;

}

